use num_bigint::BigUint;
use num_traits::{One, Zero};
use rand::{thread_rng, RngCore};
use sha2::{Digest, Sha256};

/// Generates a zero-knowledge proof for the discrete logarithm (DLOG) problem.
/// This function implements the Fiat-Shamir heuristic to create a non-interactive
/// ZKP where the prover shows knowledge of the discrete logarithm `x` such that:
/// `y = g^x mod p`, without revealing `x`.
///
/// ## Arguments
///
/// * `x` - The secret value (discrete logarithm) that the prover knows.
/// * `g` - The generator of the group (public information).
/// * `p` - The prime modulus of the group (public information).
///
/// ## Returns
///
/// * `y` - The residue `y = g^x mod p`, which is the commitment.
/// * `pf` - The proof of knowledge, which consists of two vectors:
///    - `t`: A vector of values `g^r mod p`, where `r` are random values.
///    - `s`: A vector of values `s = r + b * x`, which encodes the response
///      to the verifier's challenge bits `b`.
#[allow(dead_code)]
pub fn dlog_proof(x: BigUint, g: BigUint, p: BigUint) -> (BigUint, (Vec<BigUint>, Vec<BigUint>)) {
    let mut r = Vec::new(); // Random values used to create `t`
    let mut t = Vec::new(); // The values `g^r mod p` that will be sent to the verifier
    let mut s = Vec::new(); // The response values `s = r + b * x` to the verifier's challenge

    // Step 1: Compute y = g^x mod p, the commitment (residue).
    // This is the "challenge" value that will be shared with the verifier.
    let y = mod_exp(&g, &x, &p);

    // Step 2: Generate 100 random values `r` and compute corresponding `t` values.
    // For each iteration, we:
    // 1. Generate a random value `r`.
    // 2. Compute `t = g^r mod p` (this is a commitment based on the random value `r`).
    for _ in 0..100 {
        let ri = random_biguint_below(&p); // Generate a random value `r`
        r.push(ri.clone());
        let ti = mod_exp(&g, &ri, &p); // Compute `t = g^r mod p`
        t.push(ti); // Store the `t` value
    }

    // Step 3: Generate challenge bits `b` using the Fiat-Shamir heuristic.
    // These bits are derived from the `t` values and serve as a pseudo-random challenge.
    let b = fiat_shamir_heuristic(t.clone());

    // Step 4: Compute `s = r + b * x` for each bit `b` of the challenge.
    // The value `s` is computed in response to the challenge bits.
    for i in 0..100 {
        let bi = BigUint::from(b[i] as u64); // Convert the bit to BigUint
        s.push(&r[i] + &bi * &x); // Compute `s = r + b * x`
    }

    // Return the commitment `y` and the proof of knowledge (`t`, `s`).
    (y, (t, s))
}

/// Verifies the zero-knowledge proof of knowledge for the discrete logarithm problem.
/// This function checks if the provided proof is valid using the Fiat-Shamir heuristic.
///
/// ## Arguments
///
/// * `y` - The residue `y = g^x mod p`, which is the public commitment from the prover.
/// * `g` - The generator of the group (public information).
/// * `p` - The prime modulus of the group (public information).
/// * `pf` - The proof of knowledge, which consists of two vectors:
///    - `t`: A vector of values `g^r mod p`, where `r` are random values generated by the prover.
///    - `s`: A vector of values `s = r + b * x`, where `b` are challenge bits generated by the Fiat-Shamir heuristic.
///
/// ## Returns
///
/// * `true` - If the proof is valid and the prover knows the discrete logarithm `x`.
/// * `false` - If the proof is invalid or inconsistent with the provided values.
///
/// ## Explanation
/// The verifier checks if the proof (t, s) is consistent with the provided residue `y` and the
/// challenge bits `b` generated using the Fiat-Shamir heuristic. For each proof, the verifier
/// performs the following steps:
///
/// 1. Recompute `b`, the challenge bits, using the Fiat-Shamir heuristic on the `t` values.
/// 2. For each index `i`:
///    - Compute `lhs = g^s[i] mod p` (this is what the prover claims).
///    - Compute `rhs = t[i] * y^b[i] mod p` if `b[i] == 1`, otherwise `rhs = t[i] mod p`.
///    - Compare `lhs` and `rhs`. If they do not match for any `i`, the proof is invalid.
/// 3. If all checks pass, return `true`, meaning the proof is valid.
pub fn verify(y: BigUint, g: BigUint, p: BigUint, pf: (Vec<BigUint>, Vec<BigUint>)) -> bool {
    let (t, s) = pf;

    // Step 1: Generate challenge bits `b` using the Fiat-Shamir heuristic based on `t`.
    let b = fiat_shamir_heuristic(t.clone());

    // Step 2: For each proof, check if g^s[i] mod p is consistent with t[i] and the challenge `b`.
    for i in 0..100 {
        // Left-hand side: g^s[i] mod p
        let lhs = mod_exp(&g, &s[i], &p);

        // Right-hand side: Check against `t[i]` and `y^b mod p`.
        // If `b[i] == 1`, compute rhs = (y * t[i]) mod p.
        // Otherwise, rhs = t[i] mod p.
        let rhs = if b[i] == 1 {
            (&y * &t[i]) % &p
        } else {
            t[i].clone()
        };

        // Step 3: If lhs != rhs for any index `i`, the proof is invalid.
        if lhs != rhs {
            return false;
        }
    }

    // If all checks pass, the proof is valid.
    true
}

/// Performs modular exponentiation.
/// This function computes `(base^exp) % modulus` efficiently using the "exponentiation by squaring" method.
/// It is a crucial operation in many cryptographic algorithms, including RSA and Diffie-Hellman key exchange.
///
/// ## Arguments
/// * `base` - The base number to be exponentiated (e.g., `g` in DLOG).
/// * `exp` - The exponent to raise the base to (e.g., `x`, the secret in DLOG).
/// * `modulus` - The modulus to take after exponentiation (a large prime `p` in cryptographic groups).
///
/// ## Returns
/// * The result of `(base^exp) % modulus`, calculated efficiently.
///
/// ## Explanation
/// Modular exponentiation is fundamental in cryptography, where numbers like `exp` (exponents) are very large,
/// and directly calculating `base^exp` without taking the modulus in between would result in numbers too large to handle.
/// This function solves the problem by using **exponentiation by squaring**, which breaks down the exponentiation into
/// smaller, manageable steps while applying the modulus at every step to keep the numbers small.
///
/// ### Efficient Exponentiation by Squaring
/// The algorithm relies on representing the exponent as a binary number and successively squaring the base:
/// - If `exp` is an odd number, we multiply the result by `base`.
/// - We square the `base` and halve the exponent (using right-shifting) in each iteration.
///
/// ### Example
/// To better understand, let's say the exponent is `11`, which in binary is `1011`. This is the same as:
/// ```ignore
/// 11 = (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0)
/// ```
/// So, we can rewrite `base^11` as:
/// ```ignore
/// base^11 = base^(8 + 2 + 1) = base^8 * base^2 * base^1
/// ```
/// Instead of calculating `base^11` directly, we break it down using powers of two, and perform the modular operation
/// at each step to keep the numbers manageable:
/// ```ignore
/// (base^8 % modulus) * (base^2 % modulus) * (base^1 % modulus)
/// ```
/// This breakdown allows for much more efficient computation, especially for large numbers.
///
/// ## Algorithm Steps
/// 1. Start with `result = 1`.
/// 2. While `exp > 0`:
///    - If `exp` is odd (i.e., the least significant bit is `1`), multiply `result` by `base` and take the modulus.
///    - Square the `base` and halve `exp` (right-shift by one).
/// 3. Return `result`.
///
/// This approach ensures that the number of operations grows logarithmically with respect to the size of the exponent,
/// making it efficient even for large cryptographic operations.
fn mod_exp(base: &BigUint, exp: &BigUint, modulus: &BigUint) -> BigUint {
    let mut result = BigUint::one();
    let mut base = base.clone() % modulus;
    let mut exp = exp.clone();

    while exp > BigUint::zero() {
        if &exp % 2u32 == BigUint::one() {
            result = (result * &base) % modulus;
        }
        exp = &exp >> 1;
        base = (&base * &base) % modulus;
    }

    result
}

/// Implements the Fiat-Shamir heuristic, converting a list of values `t` into a
/// deterministic challenge in the form of a vector of bits (0 or 1).
///
/// The heuristic works by hashing the values in `t` using SHA-256, and then
/// extracting bits from the resulting hash.
///
/// # Arguments
/// * `t` - A vector of `BigUint` values, typically the commitments made by the prover.
///
/// # Returns
/// * A vector of 100 bits (u8) derived from the SHA-256 hash of the values in `t`.
///   These bits are used as the challenge in the zero-knowledge proof.
fn fiat_shamir_heuristic(t: Vec<BigUint>) -> Vec<u8> {
    let mut hasher = Sha256::new();

    for value in t {
        let value_bytes = value.to_bytes_be(); // Convert BigUint to bytes
        hasher.update(value_bytes);
    }

    let result = hasher.finalize();

    let mut bits = Vec::new();
    for byte in result.iter() {
        for i in 0..8 {
            let bit = (byte >> (7 - i)) & 1;
            bits.push(bit as u8);
            if bits.len() == 100 {
                // We only need 100 bits
                return bits;
            }
        }
    }

    bits
}

/// Generates a random `BigUint` that is strictly less than the given `modulus`.
/// This function is useful for generating random values in modular arithmetic settings.
///
/// ## Arguments
/// * `modulus` - The upper bound for the random number, a `BigUint`.
///
/// ## Returns
/// * A random `BigUint` less than the `modulus`.
///
/// ## Algorithm
/// This function generates a random byte array with a length based on the size of the `modulus`,
/// converts the byte array to a `BigUint`, and ensures it is less than the modulus.
fn random_biguint_below(modulus: &BigUint) -> BigUint {
    let mut rng = thread_rng();
    let byte_len = (modulus.bits() + 7) / 8; // Number of bytes needed to represent the modulus
    let mut random_bytes = vec![0u8; byte_len as usize];

    loop {
        // Fill the byte array with random bytes
        rng.fill_bytes(&mut random_bytes);
        // Convert the byte array to BigUint
        let random_value = BigUint::from_bytes_be(&random_bytes);
        // Ensure the random value is less than the modulus
        if &random_value < modulus {
            return random_value;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use num_bigint::BigUint;
    use std::str::FromStr;

    const PRIME_STR: &str = "273389558745553615023177755634264971227";
    const GEN_STR: &str = "191981998178538467192271372964660528157";

    #[test]
    fn test_valid_proof() {
        let prime = BigUint::from_str(PRIME_STR).unwrap();
        let gen = BigUint::from_str(GEN_STR).unwrap();
        let x = BigUint::from(17u64); // Secret value (discrete log of y)

        // Prover generates the proof
        let (y, pf) = dlog_proof(x.clone(), gen.clone(), prime.clone());

        // Verifier checks the proof
        assert!(
            verify(y, gen.clone(), prime.clone(), pf),
            "The proof should be valid."
        );
    }

    #[test]
    fn test_invalid_proof() {
        let prime = BigUint::from_str(PRIME_STR).unwrap();
        let gen = BigUint::from_str(GEN_STR).unwrap();
        let x = BigUint::from(17u64); // Secret value (discrete log of y)

        // Prover generates the proof
        let (_, pf) = dlog_proof(x.clone(), gen.clone(), prime.clone());

        // Tampered proof (using a wrong value for y)
        let tampered_y = BigUint::from(23u64);
        assert!(
            !verify(tampered_y, gen.clone(), prime.clone(), pf),
            "The proof should be invalid."
        );
    }
}
